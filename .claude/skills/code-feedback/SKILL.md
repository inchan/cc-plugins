---
name: code-feedback
description: Claude Code 결과를 분석하고 TDD/SOLID 기반의 반복적 피드백 루프를 통해 코드 품질을 개선합니다. 조사-분석-착수-계획 후 구현-리뷰-개선-검증 사이클을 실행하며, 검증 실패시 자동으로 반복합니다.
---

# Code Feedback - TDD/SOLID 반복 개선 루프

## Overview

이 스킬은 Claude Code의 작업 결과를 체계적으로 분석하고 TDD(Test-Driven Development)와 SOLID 원칙에 기반한 반복적 피드백 루프를 통해 코드 품질을 지속적으로 개선합니다.

### 핵심 워크플로우

```
[준비 단계]
조사 → 분석 → 착수 → 계획
                    ↓
[작업 사이클] ←─────────────────────────────┐
구현 → 리뷰 → 개선 → 검증 → 자기비판 → 성찰
                                           ↓
                                  [통과?] ─No─┘
                                     ↓ Yes
                                  [완료]
```

### 실행 모드

**Full Mode**: 전체 워크플로우 (준비 4단계 + 작업 6단계)
**Quick Mode**: 작업 사이클만 (준비 단계 생략)
**Review Only**: 리뷰 → 자기비판 → 성찰만 실행

## When to Use This Skill

**사용해야 하는 경우:**
- Claude Code 작업 결과의 품질을 평가하고 개선할 때
- TDD 방식으로 코드를 개발하거나 리팩토링할 때
- SOLID 원칙을 적용하여 코드 구조를 개선할 때
- 체계적인 코드 리뷰가 필요할 때
- 반복적 개선을 통해 높은 품질을 달성해야 할 때

**사용하지 않아야 하는 경우:**
- 단순한 일회성 수정
- 프로토타입 또는 POC 코드
- 테스트가 불필요한 설정 파일 수정

---

## Phase 1: 준비 단계 (Preparation)

### 1.1 조사 (Research)

```markdown
## 조사 단계

### 컨텍스트 수집 (병렬 실행)

1. **기존 코드베이스 분석**
   - 관련 파일 및 모듈 식별
   - 의존성 그래프 파악
   - 기존 테스트 커버리지 확인

2. **요구사항 명확화**
   - 기능 요구사항 정리
   - 비기능 요구사항 (성능, 보안 등)
   - 제약조건 및 경계조건

3. **기술 스택 확인**
   - 사용 중인 프레임워크/라이브러리
   - 테스트 도구 (Jest, Vitest, pytest 등)
   - 린터/포맷터 설정

### 조사 결과
- 분석 대상: [파일/모듈 목록]
- 테스트 프레임워크: [테스트 도구]
- 관련 문서: [참조 문서]
```

### 1.2 분석 (Analysis)

```markdown
## 분석 단계

### SOLID 원칙 준수 분석

| 원칙 | 현재 상태 | 위반 사항 | 개선 방향 |
|------|----------|----------|----------|
| SRP (단일 책임) | [점수/10] | [위반 내용] | [개선안] |
| OCP (개방-폐쇄) | [점수/10] | [위반 내용] | [개선안] |
| LSP (리스코프 치환) | [점수/10] | [위반 내용] | [개선안] |
| ISP (인터페이스 분리) | [점수/10] | [위반 내용] | [개선안] |
| DIP (의존성 역전) | [점수/10] | [위반 내용] | [개선안] |

### 테스트 가능성 분석

- **현재 테스트 커버리지**: X%
- **테스트 가능한 단위**: [목록]
- **모킹이 필요한 의존성**: [목록]
- **테스트 어려운 부분**: [목록] + 이유

### 코드 품질 지표

- 복잡도 (Cyclomatic): [값]
- 결합도 (Coupling): [높음/중간/낮음]
- 응집도 (Cohesion): [높음/중간/낮음]
```

### 1.3 착수 (Initiation)

```markdown
## 착수 단계

### 작업 범위 정의

**In Scope:**
- [포함되는 작업 1]
- [포함되는 작업 2]

**Out of Scope:**
- [제외되는 작업]

### 성공 기준

1. **테스트 통과율**: 100%
2. **테스트 커버리지**: >= 80%
3. **정적 분석 에러**: 0개
4. **SOLID 준수**: 각 원칙 8/10 이상

### 리스크 및 대응

| 리스크 | 확률 | 영향 | 대응 방안 |
|-------|------|-----|----------|
| [리스크 1] | [H/M/L] | [H/M/L] | [대응안] |
```

### 1.4 계획 (Planning)

```markdown
## 계획 단계

### 원자 단위 작업 분해

각 작업은 독립적으로 테스트 가능한 최소 단위입니다.

#### 작업 목록

| ID | 작업 | 우선순위 | 의존성 | 병렬 가능 | 예상 시간 |
|----|-----|---------|-------|----------|----------|
| T1 | [작업 1] | P0 | - | Yes | 10min |
| T2 | [작업 2] | P0 | - | Yes | 15min |
| T3 | [작업 3] | P1 | T1 | No | 20min |
| T4 | [작업 4] | P1 | T2 | No | 15min |
| T5 | [작업 5] | P2 | T3, T4 | No | 25min |

### 의존성 그래프

```
T1 ──┐
     ├──→ T3 ──┐
T2 ──┤         ├──→ T5
     └──→ T4 ──┘
```

### 실행 전략

**Phase A: 병렬 실행** (T1, T2)

Task 도구를 사용하여 독립 작업을 병렬로 실행합니다.
단일 메시지에서 여러 Task 호출을 포함하면 병렬 실행됩니다:

```
Task 호출 1: subagent_type="general-purpose"
  - description: "T1: [작업명]"
  - prompt: "TDD로 [기능] 구현. SOLID 원칙 준수."

Task 호출 2: subagent_type="general-purpose"
  - description: "T2: [작업명]"
  - prompt: "TDD로 [기능] 구현. SOLID 원칙 준수."
```

**Phase B: 순차 실행** (T3 → T4)
- T1 완료 후 T3 시작 (T1 결과를 T3에 전달)
- T2 완료 후 T4 시작 (T2 결과를 T4에 전달)

**Phase C: 통합** (T5)
- 모든 선행 작업 완료 후 통합
- 통합 테스트 실행
- 메인 컨텍스트에서 결과 종합

### 검증 기준

- [ ] 모든 단위 테스트 통과
- [ ] 통합 테스트 통과
- [ ] 정적 분석 통과 (lint, type check)
- [ ] 코드 리뷰 완료
```

---

## Phase 2: 작업 사이클 (Work Cycle)

### 사이클 개요

```
[Iteration N]
     ↓
[2.1 TDD/SOLID 구현]
     ↓
[2.2 리뷰]
     ↓
[2.3 개선]
     ↓
[2.4 검증]
     ↓
[2.5 자기비판] ← 개선 결과에 대한 비판적 분석
     ↓
[2.6 성찰] ← 학습 및 패턴 인식
     ↓
[품질 충족?] ──No──→ [N < MaxIteration?] ──Yes──→ [Iteration N+1]
     ↓                        ↓ No
   Pass                    [에러 보고]
     ↓
  [완료]
```

**최대 반복 횟수**: 5회 (기본값)

### 2.1 TDD/SOLID 구현 (Implementation)

```markdown
## Iteration N: 구현 단계

### TDD 사이클

#### Red: 실패하는 테스트 작성

```typescript
// test/[feature].test.ts

describe('[Feature Name]', () => {
  describe('[Unit/Function Name]', () => {
    it('should [expected behavior]', () => {
      // Arrange
      const input = [test input];

      // Act
      const result = [function call];

      // Assert
      expect(result).toBe([expected]);
    });

    it('should handle [edge case]', () => {
      // Edge case test
    });
  });
});
```

**테스트 실행 결과**: FAIL (expected)
- 실패 테스트 수: X개
- 에러 메시지: [message]

#### Green: 최소 구현

```typescript
// src/[feature].ts

// 테스트를 통과하는 최소한의 구현
export function [functionName]([params]): [returnType] {
  // Minimal implementation
}
```

**테스트 실행 결과**: PASS
- 통과 테스트 수: X개

#### Refactor: SOLID 원칙 적용

**적용된 SOLID 원칙:**

1. **SRP (단일 책임 원칙)**
   - Before: [이전 상태]
   - After: [개선된 상태]
   - 변경 사항: [구체적 변경]

2. **OCP (개방-폐쇄 원칙)**
   - Before: [이전 상태]
   - After: [개선된 상태]
   - 변경 사항: [구체적 변경]

3. **DIP (의존성 역전 원칙)**
   - Before: [하드코딩된 의존성]
   - After: [주입 가능한 의존성]
   - 변경 사항: [구체적 변경]

**리팩토링 후 테스트**: PASS
```

### 2.2 리뷰 (Review)

```markdown
## Iteration N: 리뷰 단계

### 자동 리뷰

#### 정적 분석 결과

| 도구 | 상태 | 이슈 수 | 주요 내용 |
|------|------|--------|----------|
| TypeScript | [Pass/Fail] | X | [에러 목록] |
| ESLint | [Pass/Fail] | X | [경고/에러] |
| Prettier | [Pass/Fail] | X | [포맷 이슈] |

#### 테스트 커버리지

```
--------------------------|---------|----------|---------|---------|
File                      | % Stmts | % Branch | % Funcs | % Lines |
--------------------------|---------|----------|---------|---------|
All files                 | XX.XX   | XX.XX    | XX.XX   | XX.XX   |
 src/[file].ts            | XX.XX   | XX.XX    | XX.XX   | XX.XX   |
--------------------------|---------|----------|---------|---------|
```

**커버리지 목표**: >= 80%
**현재 상태**: [달성/미달성]

### 수동 리뷰 체크리스트

#### 코드 품질

- [ ] 명확한 변수/함수 이름 사용
- [ ] 적절한 주석 및 문서화
- [ ] 중복 코드 제거
- [ ] 일관된 코딩 스타일

#### SOLID 원칙

- [ ] SRP: 각 클래스/함수가 단일 책임을 가짐
- [ ] OCP: 확장에 열려있고 수정에 닫혀있음
- [ ] LSP: 하위 타입이 상위 타입을 대체 가능
- [ ] ISP: 인터페이스가 적절히 분리됨
- [ ] DIP: 고수준 모듈이 저수준 모듈에 의존하지 않음

#### 테스트 품질

- [ ] 테스트가 행위를 테스트 (구현 아님)
- [ ] 테스트가 독립적이고 반복 가능
- [ ] 경계값 및 에지케이스 테스트
- [ ] 모킹이 적절히 사용됨

### 리뷰 결과

**발견된 이슈:**

| 심각도 | 이슈 | 위치 | 권장 조치 |
|-------|-----|-----|----------|
| Critical | [이슈 1] | [file:line] | [조치] |
| Major | [이슈 2] | [file:line] | [조치] |
| Minor | [이슈 3] | [file:line] | [조치] |

**총점**: X/10
```

### 2.3 개선 (Improvement)

```markdown
## Iteration N: 개선 단계

### 이슈 해결

#### Critical 이슈 (필수 해결)

**이슈 1: [이슈 제목]**

- **문제**: [문제 설명]
- **위치**: [file:line]
- **원인**: [근본 원인]

**수정 전:**
```typescript
// 문제가 있는 코드
```

**수정 후:**
```typescript
// 개선된 코드
```

**검증**: [테스트 결과]

#### Major 이슈

[같은 형식으로 기술]

### 추가 개선사항

**성능 최적화:**
- [최적화 1]: [효과]
- [최적화 2]: [효과]

**코드 가독성:**
- [개선 1]: [효과]
- [개선 2]: [효과]

### 개선 요약

| 카테고리 | 이전 | 이후 | 개선율 |
|---------|-----|------|-------|
| 테스트 커버리지 | X% | Y% | +Z% |
| SOLID 점수 | X/50 | Y/50 | +Z |
| 정적 분석 에러 | X개 | Y개 | -Z개 |
| 코드 복잡도 | X | Y | -Z |
```

### 2.4 검증 (Verification)

```markdown
## Iteration N: 검증 단계

### 자동 검증

#### 필수 검증 항목

| 항목 | 명령어 | 결과 | 상태 |
|------|-------|------|------|
| 단위 테스트 | `npm test` | X/Y passed | [Pass/Fail] |
| 타입 체크 | `tsc --noEmit` | X errors | [Pass/Fail] |
| 린트 | `npm run lint` | X issues | [Pass/Fail] |
| 빌드 | `npm run build` | [Success/Fail] | [Pass/Fail] |

#### 프레임워크별 추가 검증

**React/Next.js:**
```bash
pnpm build        # 빌드 검증
pnpm test         # 테스트 실행
pnpm lint         # 린트 검사
```

**Flutter:**
```bash
flutter analyze   # 정적 분석
flutter test      # 테스트 실행
```

**Python:**
```bash
pytest            # 테스트 실행
mypy .            # 타입 체크
ruff check .      # 린트 검사
```

### 검증 결과 판정

#### 통과 기준

| 기준 | 목표 | 현재 | 상태 |
|------|-----|------|------|
| 테스트 통과율 | 100% | X% | [Pass/Fail] |
| 테스트 커버리지 | >= 80% | X% | [Pass/Fail] |
| 정적 분석 에러 | 0개 | X개 | [Pass/Fail] |
| 빌드 성공 | Yes | [Yes/No] | [Pass/Fail] |

### 최종 판정

**상태**: [PASS / FAIL]

#### PASS인 경우
→ 작업 완료. 최종 보고서 생성.

#### FAIL인 경우

**실패 원인:**
- [원인 1]
- [원인 2]

**다음 반복에서 해결할 사항:**
1. [해결 사항 1]
2. [해결 사항 2]

**현재 반복**: N / 5

→ [N < 5] Iteration N+1로 진행
→ [N = 5] 최대 반복 도달. 부분 완료로 보고.
```

### 2.5 자기비판 (Self-Critique)

```markdown
## Iteration N: 자기비판 단계

### 개선 결과에 대한 비판적 분석

이 단계에서는 방금 수행한 개선이 실제로 문제를 해결했는지,
새로운 문제를 도입하지는 않았는지 비판적으로 검토합니다.

### 긍정적 측면 (잘된 점)

1. **[개선 항목 1]**
   - 달성한 것: [구체적 성과]
   - 품질 향상: [측정 가능한 개선]

2. **[개선 항목 2]**
   - 달성한 것: [구체적 성과]
   - 품질 향상: [측정 가능한 개선]

### 부정적 측면 (개선 필요)

1. **[미흡한 점 1]**
   - 문제: [구체적 문제]
   - 원인: [왜 이렇게 되었는지]
   - 개선안: [다음 반복에서 해결 방법]

2. **[미흡한 점 2]**
   - 문제: [구체적 문제]
   - 원인: [왜 이렇게 되었는지]
   - 개선안: [다음 반복에서 해결 방법]

### 놓친 것들

- [ ] [놓친 엣지케이스]
- [ ] [고려하지 않은 시나리오]
- [ ] [추가해야 할 테스트]

### 과도한 것들

- [ ] [불필요하게 복잡해진 부분]
- [ ] [과도한 추상화]
- [ ] [제거해야 할 코드]

### 대안 접근법

**고려했던 다른 방법:**
1. [대안 1]: [선택하지 않은 이유]
2. [대안 2]: [선택하지 않은 이유]

**더 나은 접근법이 있었을 수 있는 부분:**
- [부분]: [더 나은 접근법]

### 자기비판 점수

| 항목 | 점수 | 근거 |
|------|------|------|
| 문제 해결 완전성 | X/10 | [근거] |
| 부작용 최소화 | X/10 | [근거] |
| 코드 단순성 | X/10 | [근거] |
| 테스트 충분성 | X/10 | [근거] |

**종합 자기비판 점수**: X/10
```

### 2.6 성찰 (Reflection)

```markdown
## Iteration N: 성찰 단계

### 이번 반복에서 배운 것

#### 기술적 학습

1. **[학습 1]**
   - 발견: [무엇을 알게 되었는지]
   - 적용: [앞으로 어떻게 활용할지]

2. **[학습 2]**
   - 발견: [무엇을 알게 되었는지]
   - 적용: [앞으로 어떻게 활용할지]

#### 프로세스 학습

1. **효과적이었던 접근법**
   - [접근법]: [왜 효과적이었는지]

2. **비효율적이었던 접근법**
   - [접근법]: [왜 비효율적이었는지]
   - 개선: [다음에 어떻게 할지]

### 패턴 인식

#### 반복되는 문제 패턴

| 패턴 | 발생 횟수 | 근본 원인 | 예방 방법 |
|------|----------|----------|----------|
| [패턴 1] | N회 | [원인] | [예방법] |
| [패턴 2] | N회 | [원인] | [예방법] |

#### 성공 패턴

| 패턴 | 효과 | 재사용 방법 |
|------|------|------------|
| [패턴 1] | [효과] | [재사용 방법] |
| [패턴 2] | [효과] | [재사용 방법] |

### 다음 반복을 위한 전략

**우선순위 조정:**
1. [조정 1]: [이유]
2. [조정 2]: [이유]

**새로운 접근법:**
- [접근법]: [기대 효과]

**피해야 할 것:**
- [피해야 할 것]: [이유]

### 메타 인지

**현재 진행 상태에 대한 확신도**: X/10

**불확실한 부분:**
- [불확실한 부분 1]
- [불확실한 부분 2]

**도움이 필요한 부분:**
- [도움 필요 1]
- [도움 필요 2]

### 성찰 요약

**핵심 인사이트**: [이번 반복의 가장 중요한 깨달음]

**다음 반복의 초점**: [집중해야 할 핵심 영역]

**예상 결과**: [다음 반복 후 기대되는 상태]
```

---

## Phase 3: 완료 및 보고 (Completion)

### 최종 보고서

```markdown
## 작업 완료 보고서

### 요약

- **작업 ID**: [ID]
- **총 반복 횟수**: N회
- **최종 상태**: [완료/부분완료/실패]
- **소요 시간**: [시간]

### 품질 지표 변화

| 지표 | 초기 | 최종 | 변화 |
|------|-----|------|------|
| 테스트 커버리지 | X% | Y% | +Z% |
| SOLID 점수 | X/50 | Y/50 | +Z |
| 정적 분석 에러 | X개 | 0개 | -X개 |
| 코드 복잡도 | X | Y | -Z |

### SOLID 원칙 적용 결과

| 원칙 | 초기 | 최종 | 주요 개선 |
|------|-----|------|----------|
| SRP | X/10 | Y/10 | [개선 내용] |
| OCP | X/10 | Y/10 | [개선 내용] |
| LSP | X/10 | Y/10 | [개선 내용] |
| ISP | X/10 | Y/10 | [개선 내용] |
| DIP | X/10 | Y/10 | [개선 내용] |

### 생성된 산출물

1. **소스 코드**
   - [파일 목록]

2. **테스트 코드**
   - [테스트 파일 목록]
   - 커버리지: X%

3. **문서**
   - [문서 목록]

### 반복별 진행 요약

| 반복 | 주요 작업 | 해결된 이슈 | 남은 이슈 |
|------|---------|------------|----------|
| 1 | [작업] | X개 | Y개 |
| 2 | [작업] | X개 | Y개 |
| ... | ... | ... | ... |

### 후속 조치 권장사항

1. [권장사항 1]
2. [권장사항 2]
3. [권장사항 3]
```

---

## 사용 예시

### 예시 1: API 엔드포인트 개선

```
입력: "사용자 인증 API를 TDD로 리팩토링해주세요"

1. 준비 단계:
   - 조사: auth.ts, user.service.ts, 기존 테스트 분석
   - 분석: SOLID 위반 사항 식별 (DIP 위반, SRP 위반)
   - 착수: 범위 정의 및 성공 기준 설정
   - 계획: 5개 원자 작업으로 분해

2. 작업 사이클 (Iteration 1):
   - TDD: 인증 로직 테스트 작성 → 구현 → 리팩토링
   - 리뷰: 정적 분석, 커버리지 70%
   - 개선: DIP 적용 (의존성 주입)
   - 검증: 커버리지 미달 → 다음 반복

3. 작업 사이클 (Iteration 2):
   - TDD: 에러 케이스 테스트 추가
   - 리뷰: 커버리지 85%
   - 개선: SRP 적용 (책임 분리)
   - 검증: 모든 기준 통과 → 완료

결과: 2회 반복으로 품질 목표 달성
```

### 예시 2: 레거시 코드 리팩토링

```
입력: "주문 처리 모듈의 복잡도를 낮추고 테스트를 추가해주세요"

1. 준비 단계:
   - 조사: order.service.ts (복잡도 25, 커버리지 20%)
   - 분석: 모든 SOLID 원칙 위반
   - 착수: 복잡도 10 이하, 커버리지 80% 목표
   - 계획: 8개 작업으로 분해 (4개 병렬 가능)

2. 작업 사이클 (3회 반복):
   - Iteration 1: 핵심 로직 추출 및 테스트
   - Iteration 2: 의존성 분리 및 주입
   - Iteration 3: 에지케이스 처리 및 최종 검증

결과: 복잡도 8, 커버리지 87% 달성
```

---

## 설정 옵션

### 기본 설정

```yaml
maxIterations: 5          # 최대 반복 횟수
coverageThreshold: 80     # 최소 테스트 커버리지 (%)
solidThreshold: 8         # 각 SOLID 원칙 최소 점수 (10점 만점)
staticAnalysisErrors: 0   # 허용 정적 분석 에러 수
```

### 프로젝트별 커스터마이징

테스트 도구, 린터, 빌드 명령어 등을 프로젝트에 맞게 조정 가능합니다.

---

## 다른 스킬과의 통합

### intelligent-task-router와 연동

```
Router: 코드 개선 요청 감지
→ Route to: code-feedback
→ 준비 단계 실행
→ 작업 사이클 반복
```

### parallel-task-executor와 연동

```
code-feedback: 계획 단계에서 병렬 작업 식별
→ parallel-task-executor: 독립 작업 동시 실행
→ code-feedback: 결과 통합 후 검증
```

### iterative-quality-enhancer와 차이점

| 항목 | code-feedback | iterative-quality-enhancer |
|------|--------------|---------------------------|
| 초점 | TDD/SOLID 기반 개발 | 일반 품질 평가 |
| 준비 단계 | 4단계 상세 준비 | 즉시 평가 시작 |
| 평가 기준 | SOLID + 테스트 | 5개 품질 차원 |
| 작업 방식 | 테스트 먼저 작성 | 코드 먼저 평가 |

---

## Best Practices

1. **명확한 목표 설정**: 시작 전 구체적인 품질 목표 정의
2. **작은 단위로 분해**: 각 작업이 30분 이내에 완료 가능하도록
3. **테스트 우선**: 항상 테스트를 먼저 작성
4. **점진적 리팩토링**: 한 번에 하나의 SOLID 원칙 적용
5. **조기 실패**: 검증 실패시 빠르게 다음 반복으로 이동

---

## 제한사항

- 최대 5회 반복 후에도 검증 실패시 수동 개입 필요
- 복잡한 레거시 코드는 여러 세션에 걸쳐 작업 권장
- UI 컴포넌트의 경우 추가적인 시각적 테스트 필요

---

## Summary

Code Feedback 스킬은 체계적인 준비 단계와 TDD/SOLID 기반의 반복적 개선 루프를 통해 고품질 코드를 달성합니다:

1. **준비 단계**: 조사 → 분석 → 착수 → 계획
2. **작업 사이클**: 구현 → 리뷰 → 개선 → 검증 (반복)
3. **완료**: 품질 목표 달성시 최종 보고

이 접근법은 특히 다음과 같은 경우에 효과적입니다:
- **테스트 기반 개발**이 필요한 경우
- **SOLID 원칙** 준수가 중요한 경우
- **반복적 개선**을 통해 품질을 높여야 하는 경우
- **체계적인 계획**이 필요한 복잡한 작업
